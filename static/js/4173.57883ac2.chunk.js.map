{"version":3,"file":"static/js/4173.57883ac2.chunk.js","mappings":"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","sources":["../node_modules/@siemens/ix/dist/esm/src/components/utils/find-element.ts","../node_modules/@siemens/ix/dist/esm/src/components/tooltip/tooltip.scss?tag=ix-tooltip&encapsulation=shadow","../node_modules/@siemens/ix/dist/esm/src/components/tooltip/tooltip.tsx","../node_modules/@siemens/ix/dist/esm/src/components/utils/make-ref.ts","../node_modules/@siemens/ix/dist/esm/src/components/utils/disposable-event-listener.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2024 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Will try to resolve the selector in the light dom, shadow dom or slot\n * @param selector The selector to resolve\n * @param hostElement The element to start the search from\n * @returns Promise with the resolved elements or undefined if not found\n */\nexport async function resolveSelector(\n  selector: string,\n  hostElement?: HTMLElement\n): Promise<HTMLElement[] | undefined> {\n  const elements: HTMLElement[] = Array.from(\n    document.querySelectorAll(selector)\n  );\n\n  if (elements.length > 0) {\n    return Promise.resolve(elements);\n  }\n\n  if (hostElement === undefined) {\n    return Promise.resolve(undefined);\n  }\n\n  const shadowRoot = getRootFor(hostElement);\n\n  if (shadowRoot === undefined || !(shadowRoot instanceof ShadowRoot)) {\n    return Promise.resolve(undefined);\n  }\n\n  const elementsInShadowRoot: HTMLElement[] = Array.from(\n    shadowRoot.querySelectorAll(selector)\n  );\n\n  const elementsInHost: HTMLElement[] = Array.from(\n    shadowRoot.host.querySelectorAll(selector)\n  );\n\n  const elementsInComponent: HTMLElement[] = [\n    ...elementsInHost,\n    ...elementsInShadowRoot,\n  ];\n\n  if (elementsInComponent.length > 0) {\n    return Promise.resolve(elementsInComponent);\n  }\n\n  return Promise.resolve(undefined);\n}\n\n/**\n * Walk up the DOM to find the nearest shadow root\n * @param element The element to get the root for\n * @param parent This will determine how far up the DOM to travel to find the root\n * @returns The root element\n */\nexport function getRootFor(element: HTMLElement, parent = document.body) {\n  if (!element.parentElement && !element.parentNode) {\n    return undefined;\n  }\n\n  if (element.parentNode instanceof ShadowRoot) {\n    return element.parentNode;\n  }\n\n  let currentNode = element.parentElement;\n\n  while (currentNode) {\n    if (currentNode.shadowRoot) {\n      return currentNode.shadowRoot;\n    } else if (currentNode.parentNode instanceof ShadowRoot) {\n      return currentNode.parentNode;\n    }\n\n    currentNode = currentNode.parentElement;\n  }\n\n  return parent;\n}\n\nexport function waitForSelector(\n  selector: string,\n  node = document,\n  hostElement?: HTMLElement\n): Promise<Element> {\n  return new Promise((resolve) => {\n    const waitForElements = () => {\n      resolveSelector(selector, hostElement).then((elements) => {\n        if (elements && elements.length > 0) {\n          resolve(elements[0]);\n          observer?.disconnect();\n        }\n      });\n    };\n\n    waitForElements();\n\n    const observer = new MutationObserver(() => {\n      waitForElements();\n    });\n\n    observer.observe(node.body, {\n      childList: true,\n      subtree: true,\n    });\n  });\n}\n\n/**\n * Find an element by ID or reference\n * @param element The element to find\n * @param hostElement The element to start the search from\n * @returns A promise that will resolve to the element\n */\nexport function findElement(\n  element: string | HTMLElement | Promise<HTMLElement>,\n  hostElement?: HTMLElement\n): Promise<Element> {\n  if (element instanceof Promise) {\n    return element;\n  }\n\n  if (typeof element === 'object') {\n    return Promise.resolve(element);\n  }\n\n  const selector = `#${element}`;\n  return waitForSelector(selector, document, hostElement);\n}\n","/*\n * SPDX-FileCopyrightText: 2025 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n.dialog {\n  margin: 0;\n  padding: 0;\n  border: none;\n  max-width: 18.25rem;\n  width: max-content;\n  background-color: transparent;\n  overflow-wrap: break-word;\n  box-shadow: none;\n  overflow: visible;\n}\n\n.tooltip-container {\n  display: block;\n  position: relative;\n  width: auto;\n  height: 100%;\n  background: var(--theme-tootlip--background);\n  color: var(--theme-color-std-text);\n  padding: 0.375rem 0.75rem 0.375rem 0.875rem;\n\n  box-shadow: var(--theme-shadow-4);\n  border-radius: 0.25rem;\n}\n\n.content-wrapper {\n  overflow: auto;\n}\n\n.tooltip-title {\n  display: flex;\n  align-items: center;\n\n  ::slotted(ix-icon) {\n    margin-right: 0.35rem;\n  }\n}\n\n.arrow,\n.arrow::before {\n  position: absolute;\n  width: 12px;\n  height: 12px;\n  background: inherit;\n}\n\n.arrow {\n  visibility: hidden;\n}\n\n.arrow::before {\n  visibility: visible;\n  content: '';\n  transform: rotate(45deg);\n  background-color: var(--theme-tootlip--background);\n}\n","/*\n * SPDX-FileCopyrightText: 2025 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  arrow,\n  autoUpdate,\n  computePosition,\n  ComputePositionReturn,\n  flip,\n  hide,\n  offset,\n  shift,\n} from '@floating-ui/dom';\nimport {\n  Component,\n  Element,\n  h,\n  Host,\n  Method,\n  Prop,\n  State,\n} from '@stencil/core';\nimport { resolveSelector } from '../utils/find-element';\nimport { ElementReference } from 'src/components';\nimport { makeRef } from '../utils/make-ref';\nimport { addDisposableEventListenerAsArray } from '../utils/disposable-event-listener';\n\ntype ArrowPosition = {\n  top?: string;\n  left?: string;\n  right?: string;\n};\n\nconst numberToPixel = (value?: number | null) =>\n  value !== null ? `${value}px` : '';\n\nlet tooltipInstance = 0;\n\n/**\n * @slot title-icon - Icon of tooltip title\n * @slot title-content - Content of tooltip title\n */\n@Component({\n  tag: 'ix-tooltip',\n  styleUrl: 'tooltip.scss',\n  shadow: true,\n})\nexport class Tooltip {\n  /**\n   * CSS selector for hover trigger element e.g. `for=\"[data-my-custom-select]\"`\n   */\n  @Prop() for?: ElementReference | ElementReference[];\n\n  /**\n   * Title of the tooltip\n   */\n  @Prop() titleContent?: string;\n\n  /**\n   * Define if the user can access the tooltip via mouse.\n   */\n  @Prop() interactive = false;\n\n  /**\n   * Initial placement of the tooltip.\n   * If the selected placement doesn't have enough space, the tooltip will be repositioned to another location.\n   */\n  @Prop() placement: 'top' | 'right' | 'bottom' | 'left' = 'top';\n\n  /** @internal */\n  @Prop() showDelay = 0;\n\n  /** @internal */\n  @Prop() hideDelay = 50;\n\n  /** @internal */\n  @Prop() animationFrame = false;\n\n  @Element() hostElement!: HTMLIxTooltipElement;\n\n  @State() private visible = false;\n\n  private hideTooltipTimeout?: NodeJS.Timeout;\n  private showTooltipTimeout?: NodeJS.Timeout;\n  private visibleFor?: Element;\n\n  private disposeAutoUpdate?: () => void;\n  private disposeTriggerListener?: () => void;\n  private disposeTooltipListener?: () => void;\n  private disposeDomChangeListener?: () => void;\n\n  private readonly instance = tooltipInstance++;\n\n  private readonly dialogRef = makeRef<HTMLDialogElement>();\n\n  private get arrowElement(): HTMLElement {\n    return this.hostElement.shadowRoot!.querySelector('.arrow')!;\n  }\n\n  /** @internal */\n  @Method()\n  async showTooltip(anchorElement: Element) {\n    this.clearTimeouts();\n\n    if (this.showTooltipTimeout || this.visibleFor === anchorElement) {\n      return;\n    }\n\n    const dialog = await this.dialogRef.waitForCurrent();\n\n    this.showTooltipTimeout = setTimeout(() => {\n      this.setAnchorElement(anchorElement);\n      dialog.showPopover();\n      this.applyTooltipPosition(anchorElement, dialog);\n      this.registerTooltipListener(dialog);\n    }, this.showDelay);\n  }\n\n  /** @internal */\n  @Method()\n  async hideTooltip(hideDelay: number = this.hideDelay) {\n    this.clearTimeouts();\n\n    if (this.hideTooltipTimeout || !this.visible) {\n      return;\n    }\n\n    if (this.interactive && hideDelay === 50) {\n      hideDelay = 150;\n    }\n\n    const dialog = await this.dialogRef.waitForCurrent();\n\n    this.hideTooltipTimeout = setTimeout(() => {\n      this.setAnchorElement();\n      dialog.hidePopover();\n      this.disposeAutoUpdate?.();\n      this.disposeTooltipListener?.();\n    }, hideDelay);\n  }\n\n  private setAnchorElement(anchorElement?: Element) {\n    if (!anchorElement) {\n      this.visibleFor = undefined;\n      this.visible = false;\n    } else {\n      this.visibleFor = anchorElement;\n      this.visible = true;\n    }\n  }\n\n  private computeArrowPosition({\n    placement,\n    middlewareData,\n  }: ComputePositionReturn): ArrowPosition | undefined {\n    let { x, y } = middlewareData.arrow!;\n    const resetPosition = {\n      top: 'unset',\n      right: 'unset',\n      bottom: 'unset',\n      left: 'unset',\n    };\n\n    if (placement.startsWith('top')) {\n      return {\n        ...resetPosition,\n        left: numberToPixel(x),\n        top: numberToPixel(y),\n      };\n    }\n\n    if (placement.startsWith('right')) {\n      return {\n        ...resetPosition,\n        left: numberToPixel(-6),\n        top: numberToPixel(y),\n      };\n    }\n\n    if (placement.startsWith('bottom')) {\n      return {\n        ...resetPosition,\n        left: numberToPixel(x),\n        top: numberToPixel(-6),\n      };\n    }\n\n    if (placement.startsWith('left')) {\n      return {\n        ...resetPosition,\n        right: numberToPixel(-6),\n        top: numberToPixel(y),\n      };\n    }\n  }\n\n  private async computeTooltipPosition(\n    target: Element,\n    dialog: HTMLDialogElement\n  ): Promise<ComputePositionReturn> {\n    return computePosition(target, dialog, {\n      strategy: 'fixed',\n      placement: this.placement,\n      middleware: [\n        shift(),\n        offset(12),\n        arrow({\n          element: this.arrowElement,\n        }),\n        flip({\n          fallbackStrategy: 'initialPlacement',\n          fallbackAxisSideDirection: 'end',\n          padding: 10,\n        }),\n        hide(),\n      ],\n    });\n  }\n\n  private applyTooltipArrowPosition(computeResponse: ComputePositionReturn) {\n    const arrowPosition = this.computeArrowPosition(computeResponse);\n    Object.assign(this.arrowElement.style, arrowPosition);\n  }\n\n  private async applyTooltipPosition(\n    target: Element,\n    dialog: HTMLDialogElement\n  ): Promise<ComputePositionReturn | undefined> {\n    if (!target) {\n      return;\n    }\n\n    return new Promise<ComputePositionReturn>((resolve) => {\n      this.disposeAutoUpdate?.();\n\n      this.disposeAutoUpdate = autoUpdate(\n        target,\n        dialog,\n        async () => {\n          const computeResponse = await this.computeTooltipPosition(\n            target,\n            dialog\n          );\n\n          const isHidden = computeResponse.middlewareData.hide?.referenceHidden;\n\n          if (isHidden) {\n            this.hideTooltip(0);\n            resolve(computeResponse);\n          }\n\n          if (computeResponse.middlewareData.arrow) {\n            this.applyTooltipArrowPosition(computeResponse);\n          }\n\n          const { x, y } = computeResponse;\n          Object.assign(dialog.style, {\n            left: numberToPixel(x),\n            top: numberToPixel(y),\n          });\n\n          resolve(computeResponse);\n        },\n        {\n          ancestorResize: true,\n          ancestorScroll: true,\n          elementResize: true,\n          animationFrame: this.animationFrame,\n        }\n      );\n    });\n  }\n\n  private async queryAnchorElements(): Promise<HTMLElement[] | undefined> {\n    if (this.for) {\n      if (Array.isArray(this.for)) {\n        return this.resolveElements(this.for);\n      } else {\n        return this.resolveElements([this.for]);\n      }\n    }\n  }\n\n  private async resolveElements(\n    references: ElementReference[]\n  ): Promise<HTMLElement[]> {\n    const elements: HTMLElement[] = [];\n\n    await Promise.all(\n      references.map(async (reference) => {\n        if (typeof reference === 'string') {\n          const resolvedElements = await resolveSelector(\n            reference,\n            this.hostElement\n          );\n\n          if (resolvedElements) {\n            elements.push(...resolvedElements);\n          }\n        } else if (reference instanceof HTMLElement) {\n          elements.push(reference);\n        } else if (reference instanceof Promise) {\n          elements.push(await reference);\n        }\n      })\n    );\n\n    return elements;\n  }\n\n  private async registerTriggerListener() {\n    this.disposeTriggerListener?.();\n\n    const triggerElementList = await this.queryAnchorElements();\n\n    if (!triggerElementList) {\n      return;\n    }\n\n    const listeners: {\n      element: Element | Window | Document;\n      eventType: string;\n      callback: EventListenerOrEventListenerObject;\n    }[] = [];\n\n    triggerElementList.forEach((element) => {\n      listeners.push(\n        ...[\n          {\n            element: element,\n            eventType: 'mouseenter',\n            callback: () => {\n              this.showTooltip(element);\n            },\n          },\n          {\n            element: element,\n            eventType: 'mouseleave',\n            callback: () => {\n              this.hideTooltip();\n            },\n          },\n          {\n            element: element,\n            eventType: 'focus',\n            callback: () => {\n              this.showTooltip(element);\n            },\n          },\n          {\n            element: element,\n            eventType: 'focusout',\n            callback: () => {\n              this.hideTooltip();\n            },\n          },\n        ]\n      );\n    });\n\n    this.disposeTriggerListener = addDisposableEventListenerAsArray(listeners);\n  }\n\n  private registerTooltipListener(dialog: HTMLDialogElement) {\n    this.disposeTooltipListener?.();\n\n    this.disposeTooltipListener = addDisposableEventListenerAsArray([\n      {\n        element: dialog,\n        eventType: 'mouseenter',\n        callback: () => {\n          if (this.interactive) {\n            this.clearHideTimeout();\n          }\n        },\n      },\n      {\n        element: dialog,\n        eventType: 'focus',\n        callback: () => {\n          if (this.interactive) {\n            this.clearHideTimeout();\n          }\n        },\n      },\n      {\n        element: dialog,\n        eventType: 'mouseleave',\n        callback: () => {\n          this.hideTooltip();\n        },\n      },\n      {\n        element: dialog,\n        eventType: 'focusout',\n        callback: () => {\n          this.hideTooltip();\n        },\n      },\n      {\n        element: dialog,\n        eventType: 'click',\n        callback: (event: Event) => {\n          event.stopPropagation();\n        },\n      },\n      {\n        element: document,\n        eventType: 'keydown',\n        callback: (event: Event) => {\n          if ((event as KeyboardEvent).key === 'Escape') {\n            this.hideTooltip();\n          }\n        },\n      },\n    ]);\n  }\n\n  private registerDomChangeListener() {\n    const observer = new MutationObserver(() => {\n      this.registerTriggerListener();\n    });\n\n    observer.observe(document.body, {\n      attributes: true,\n      attributeFilter: ['data-ix-tooltip'],\n      childList: true,\n      subtree: true,\n    });\n\n    this.disposeDomChangeListener = () => {\n      observer.disconnect();\n    };\n  }\n\n  private clearHideTimeout() {\n    clearTimeout(this.hideTooltipTimeout);\n    this.hideTooltipTimeout = undefined;\n  }\n\n  private clearShowTimeout() {\n    clearTimeout(this.showTooltipTimeout);\n    this.showTooltipTimeout = undefined;\n  }\n\n  private clearTimeouts() {\n    this.clearHideTimeout();\n    this.clearShowTimeout();\n  }\n\n  componentWillLoad() {\n    this.registerTriggerListener();\n  }\n\n  componentDidLoad() {\n    this.registerDomChangeListener();\n  }\n\n  disconnectedCallback() {\n    this.clearTimeouts();\n\n    this.disposeAutoUpdate?.();\n    this.disposeTriggerListener?.();\n    this.disposeTooltipListener?.();\n    this.disposeDomChangeListener?.();\n  }\n\n  render() {\n    return (\n      <Host role=\"tooltip\" class={{ visible: this.visible }}>\n        <dialog\n          ref={this.dialogRef}\n          id={'tooltip-' + this.instance}\n          class=\"dialog\"\n          popover=\"manual\"\n          inert={!this.visible}\n        >\n          <div class=\"tooltip-container\">\n            <div class=\"content-wrapper\">\n              <div class={'tooltip-title'}>\n                <slot name=\"title-icon\"></slot>\n                <ix-typography format=\"h5\">\n                  {this.titleContent}\n                  <slot name=\"title-content\"></slot>\n                </ix-typography>\n              </div>\n              <slot></slot>\n              <div class=\"arrow\"></div>\n            </div>\n          </div>\n        </dialog>\n      </Host>\n    );\n  }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type MakeRef<T> = {\n  (ref: T | undefined | null): void;\n  current: T | null;\n  waitForCurrent(): Promise<T>;\n};\n\ntype Resolve<T> = (value: T) => void;\n\nexport function makeRef<T>(\n  currentChangedCallback?: (element: T) => void\n): MakeRef<T> {\n  let resolve: Resolve<T> | undefined = undefined;\n  let currentPromise = new Promise<T>((res) => (resolve = res));\n  let current: T | undefined = undefined;\n\n  const setRefFunction = (ref: T | undefined) => {\n    if (ref === undefined) {\n      return;\n    }\n    current = (setRefFunction as MakeRef<T>).current = ref;\n    currentChangedCallback?.(ref);\n    resolve?.(ref);\n  };\n\n  setRefFunction.current = current as T | null;\n\n  setRefFunction.waitForCurrent = async () => {\n    await currentPromise;\n    return current;\n  };\n\n  return setRefFunction as MakeRef<T>;\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport type DisposableEventListener = () => void;\n\nexport const addDisposableEventListener = (\n  element: Element | Window | Document,\n  eventType: string,\n  callback: EventListenerOrEventListenerObject\n): DisposableEventListener => {\n  element.addEventListener(eventType, callback);\n\n  return () => {\n    element.removeEventListener(eventType, callback);\n  };\n};\n\nexport const addDisposableEventListenerAsArray = (\n  listener: {\n    element: Element | Window | Document;\n    eventType: string;\n    callback: EventListenerOrEventListenerObject;\n  }[]\n): DisposableEventListener => {\n  const disposables = listener.map(({ callback, element, eventType }) =>\n    addDisposableEventListener(element, eventType, callback)\n  );\n\n  return () => disposables.forEach((dispose) => dispose());\n};\n"],"names":["async","resolveSelector","selector","hostElement","elements","Array","from","document","querySelectorAll","length","Promise","resolve","undefined","shadowRoot","element","parent","arguments","body","parentElement","parentNode","ShadowRoot","currentNode","getRootFor","elementsInShadowRoot","elementsInComponent","host","findElement","node","waitForElements","then","observer","disconnect","MutationObserver","observe","childList","subtree","waitForSelector","concat","numberToPixel","value","tooltipInstance","Tooltip","constructor","hostRef","interactive","placement","showDelay","hideDelay","animationFrame","visible","instance","dialogRef","makeRef","arrowElement","this","querySelector","showTooltip","anchorElement","clearTimeouts","showTooltipTimeout","visibleFor","dialog","waitForCurrent","setTimeout","setAnchorElement","showPopover","applyTooltipPosition","registerTooltipListener","hideTooltip","hideTooltipTimeout","hidePopover","_a","disposeAutoUpdate","call","_b","disposeTooltipListener","computeArrowPosition","_ref","middlewareData","x","y","arrow","resetPosition","top","right","bottom","left","startsWith","Object","assign","computeTooltipPosition","target","computePosition","strategy","middleware","shift","offset","flip","fallbackStrategy","fallbackAxisSideDirection","padding","hide","applyTooltipArrowPosition","computeResponse","arrowPosition","style","autoUpdate","referenceHidden","ancestorResize","ancestorScroll","elementResize","queryAnchorElements","for","isArray","resolveElements","references","all","map","reference","resolvedElements","push","HTMLElement","registerTriggerListener","disposeTriggerListener","triggerElementList","listeners","forEach","eventType","callback","addDisposableEventListenerAsArray","clearHideTimeout","event","stopPropagation","key","registerDomChangeListener","attributes","attributeFilter","disposeDomChangeListener","clearTimeout","clearShowTimeout","componentWillLoad","componentDidLoad","disconnectedCallback","_c","_d","render","h","Host","role","class","ref","id","popover","inert","name","format","titleContent","currentChangedCallback","current","currentPromise","res","setRefFunction","addDisposableEventListener","addEventListener","removeEventListener","listener","disposables","dispose"],"sourceRoot":""}